/**
 * File:	modules/ProfileManager.ycp
 * Package:	Configuration of profile-manager
 * Summary:	Data for configuration of profile-manager, input and output funcs.
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of profile-manager.
 * Input and output routines.
 */

{

module "ProfileManager";
textdomain "profile-manager";

import "Directory";
import "FileUtils";
import "Label";
import "Mode";
import "NetworkService";
import "Package";
import "Popup";
import "Progress";
import "Report";
import "String";
import "Users";
import "UsersCache";


/**
 * Is SCPM enabled?
 */
global boolean enabled = false;

/**
 * Is SCPM re-initialization needed? (possibly after update)
 */
global boolean needs_reinit = false;

/**
 * Is SCPM recovery? (after something failed)
 */
global boolean needs_recover = false;


/**
 * Was enabled/disabled status changed?
 */
global boolean status_modified	= false;

/**
 * if resource groups were modified
 */
global boolean resource_groups_modified	= false;

/**
 * if SCPM DB needs to be saved (-> SCPM object desctructor)
 */
boolean save_db	= false;

/**
 * if SCPM configuration (stored in scpm_conf map) was modified
 */
global boolean conf_modified	= false;

/**
 * if list of users was modified
 */
global boolean users_modified	= false;

/**
 * Is SCPM initialized?
 * This is set to true after first enabling.
 */
global boolean initialized = false;

/**
 *  When scpm action fails, the error message is stored here by SetError()
 */
global string scpm_error = "";

/**
 * this map holds the contents of scpm.conf configuration file
 */
global map scpm_conf = $[];


/**
 * all resource groups available; filled by ReadResourceGroups()
 */
global map resource_groups = $[];

/**
 * list of resource groups marked for deletion
 */
global list resource_groups_deleted = [];

/**
 * Map of users with permissions to run SCPM
 */
map<string,string> users = $[];

/**
 * If users are available to switch profiles
 */
global boolean users_allowed	= false;

/**
 * List of user names, read from system via Users module
 */
list<string> usernames	= [];

/**
 * path to scpm qt front-end
 */
string sumfpath	= "/usr/bin/sumf";

// path to scpm bin
string scpmpath	= "/usr/sbin/scpm";

/**
 * path to config file with users
 */
string userspath = "/etc/scpm.users";

/**
 * The name of the file, where the progress state is beeing written.
 * (The same name must use the scpm agent!)
 */
string progressfile = "/scpm.progress";
string hashfile = "/scpm.hash";
string progresspath = "";
string hashpath = "";
string last_ret = "";

/**
 * how many lines of progress has been pruducted
 */
integer progress_size = 0;

/**
 * how many times was progress bar used
 */
global integer hash_size = 0;


/**
 * Was anything modified?
 */
global define boolean Modified () {
    return conf_modified || resource_groups_modified || status_modified ||
    users_modified;
}

/**
 * This function is called when some scpm command failed.
 * The error message is read and shown in Popup::Error.
 */
define void ShowError () ``{

    string err = (string) SCR::Read (.scpm.error);
    if (err != nil && err != "")
        Popup::Error (err);
}

/**
 * This function is called when some scpm command failed.
 * The error message is read and stored in global variable scpm_error.
 */
define void SetError () ``{

    string err = (string) SCR::Read (.scpm.error);
    if (err != nil && err != "")
        scpm_error = err;
    else
        scpm_error = "";
}


/**
 * Writes modified resource group.
 * @param groupname resource group name
 * @param resources list of resources belonging to this group
 * @param descr group description
 * @return success
 */
define boolean SetResourceGroup(string groupname, list resources, string descr) ``{

    boolean ret = SCR::Write(add(.scpm.rg.group, groupname), resources, descr);
    if (!ret)
    {
	SetError();
    }
    return ret;
}

/**
 * Gets resources of resource group.
 * @param groupname resource group name
 * @return list of resources
 */
global define list GetResourceGroupResources(string groupname) ``{

    list resource_group = (list) SCR::Read(.scpm.rg.group, groupname);
    if (resource_group == nil)
    {
	SetError();
	return [];
    }
    return resource_group;
}

/**
 * Reads all available resource groups.
 * @return true on success
 */
global define boolean ReadResourceGroups() ``{

    resource_groups = (map) SCR::Read(.scpm.rg);
    resource_groups_deleted = [];
    if (resource_groups == nil)
    {
	SetError();
	return false;
    }
    foreach (string name, map group, (map<string,map>)resource_groups, ``{
	resource_groups[name,"resources"] = GetResourceGroupResources (name);
    });

    return true;
}

global define map ReadResourceGroup(string groupname) ``{

    map resource_group = (map) SCR::Read(.scpm.rg.group_map, groupname);
    if (resource_group == nil)
    {
	SetError();
	return $[];
    }
    return resource_group;
}

// get the default values for given resource group
global define map GetDefaultResourceGroup (string groupname) {

    map resource_group = (map) SCR::Read (.scpm.rg.group_default, groupname);
    if (resource_group == nil)
    {
	ShowError();
	return $[];
    }
    return resource_group;
}

/**
 * get the map of default resource groups
 */
global define map<string,map> GetDefaultResourceGroups () {

    map<string,map> default_groups = (map<string,map>) SCR::Read(.scpm.rg);
    if (default_groups == nil)
    {
	ShowError();
	return $[];
    }
    foreach (string name, map group, default_groups, {
	default_groups[name] = union (group, GetDefaultResourceGroup (name));
    });

    return default_groups;
}

/**
 * Resets RG's to default values
 * @return success
 */
global define boolean ResetResourceGroups() ``{

    boolean ret = (boolean) SCR::Execute (.scpm.rg.reset);
    if (!ret)
	SetError();
    return ret;
}

/**
 * Resets one resource group to default values
 * @return success
 */
global define boolean ResetResourceGroup (string groupname) ``{

    boolean ret = (boolean) SCR::Execute (.scpm.rg.group.reset, groupname);
    if (!ret)
	SetError();
    return ret;
}


/**
 * Returns all available resource groups.
 * @return map of groups
 */
global define map<string,map> GetResourceGroups() ``{

    return (map<string,map>) resource_groups;
}

/**
 * Read the set of users allowed to run SCPM
 */
global define boolean ReadUsers () {

    if (! FileUtils::Exists (userspath))
	return false;

    users	= $[];

    string wholefile	= (string)SCR::Read (.target.string, userspath);
    list<string> lines	= splitstring (wholefile, "\n");
    foreach (string line, lines, {
	if (line == "" || substring (line, 0, 1) == "#")
	    return;
	list ll	= splitstring (line, " \t");
	if (size (ll) > 1)
	    users[ll[0]:""]	= ll[1]:"";
    });
    return true;
}

/**
 * Write new set of users allowed to run scpm
 */
global define boolean WriteUsers () {

    string wholefile	= (string)SCR::Read (.target.string, userspath);
    list<string> lines	= splitstring (wholefile, "\n");
    list<string> new_lines	= filter (string line, lines, {
	return substring (line, 0, 1) == "#";
    });
    foreach (string name, string perm, users, {
	new_lines	= add (new_lines, sformat ("%1\t%2", name, perm));
    });
    return SCR::Write (.target.string, userspath, mergestring (new_lines,"\n"));
}

/**
 * Return the map of users able to run scpm
 */
global define map<string,string> GetUsers () {

    return users;
}

/**
 * Check if users are able to switch profiles
 * @return the result
 */
global define boolean GetUsersAllowed () {

    string cmd	= "test -u " + scpmpath;
    if (FileUtils::Exists (sumfpath))
	cmd = cmd + " -a -u " + sumfpath;
    return (SCR::Execute (.target.bash, cmd) == 0);
}

/**
 * Write the new status if the users are allowed to run SCPM or not
 * @return success of the action
 */
global define boolean WriteUsersAllowed () {

    if (GetUsersAllowed () == users_allowed) // no change
	return true;

    boolean ret	= true;
    foreach (string apppath, [ scpmpath, sumfpath ], {

	if (!ret || !FileUtils::Exists (apppath))
	    return;

	string cmd	=
	    sformat ("/bin/chmod %1s %2", users_allowed ? "+" : "-", apppath);
	map out	= (map) SCR::Execute (.target.bash_output, cmd);
	if (out["stderr"]:"" != "")
	{
	    y2warning ("error calling %1: %2", cmd, out["stderr"]:"");
	    ret = false;
	}
    });
    return ret;
}

/**
 * Upodate the global map of users
 * @param map current map of users
 */
global define boolean SetUsers (map<string,string> current_users) {

    if (!users_modified && users != current_users)
	users_modified	= true;
    users	= eval (current_users);
    return users_modified;
}

/**
 * Return list of user names available in system
 * First time, read it using yast2-users, use cache for later calls.
 * @return list of user names (for local users)
 */
global define list<string> GetUsernames () {

    if (usernames == [])
    {
	// busy popup text
	Popup::ShowFeedback ("", _("Reading list of users..."));
	boolean gui = Users::GetGUI ();
	Users::SetGUI (false);
	Users::Read ();
	usernames	= UsersCache::GetUsernames("local");
	Users::SetGUI (gui);
	Popup::ClearFeedback ();
    }
    return usernames;
}




/**
 * Store error messages generated by multiple commands to one string
 */
define string AllErrorMessages (string error) ``{

    if (scpm_error != "")
    {
	if (error != "")
	    error = error + "\n";
	error = error + scpm_error;
	scpm_error = "";
    }
    return error;
}

/**
 * Save the resource groups edited in YaST UI
 * @return success
 */
global define boolean SaveResourceGroups () ``{

    scpm_error = "";
    string error = "";

    // deletion must be done in first cycle
    // (because some new group can have the name of deleted one)
    foreach (string name, (list<string>) resource_groups_deleted, ``{

	y2milestone ("deleting group %1", name);
	if (!SCR::Write (.scpm.rg.group.delete, name))
	    SetError();
	// deactivate deleted group
	SCR::Write (.scpm.rg.group.activate, name, false);
	error = AllErrorMessages (error);
    });
    resource_groups_deleted	= [];
    // renaming must be done in second cycle
    // (because some new group can have the old name of renamed one)
    foreach (string name, map group, (map<string,map<string,any> >) resource_groups, ``{
	if (group["what"]:"" == "renamed")
	{
	    y2milestone ("renaming group %1 to %2", group["org_name"]:"", name);
	    if (!SCR::Write (
		    add (.scpm.rg.group.rename, group["org_name"]:name),
		    name))
		SetError();
	}
	error = AllErrorMessages (error);
    });
    // rest of modifications
    foreach (string name, map group, (map<string,map<string,any> >) resource_groups, ``{
	string what = group["what"]:"";

	if (what == "added" || what == "edited")
	{
	    y2milestone ("saving modified group %1", name);
	    if (!SCR::Write (
		    add (.scpm.rg.group.set, name),
		    group["resources"]:[],
		    group["description"]:""))
		SetError();
	}
	// do Activation/Deactivation (it is not done in Set/Rename)
	if (group["user_modified"]:false)
	{
	    boolean activate = group["active"]:true;
	    if (!SCR::Write (.scpm.rg.group.activate, name, activate))
		SetError();
	    y2milestone ("changed active status of %1 to %2", name, activate);
	}
	error = AllErrorMessages (error);
    });
    if (error != "")
	scpm_error = error;
    return (scpm_error == "");
}

/**
 * reads a contents of scpm config file (/etc/scpm.conf)
 * @return false when file doesn't exist
 */
global define boolean ReadConfigFile () ``{

    if (! FileUtils::Exists ("/etc/scpm.conf"))
	return false;

    scpm_conf = $[
	"debug"	:	((string) SCR::Read(.sysconfig.scpm.DEBUG) == "yes"),
	"verbose":	((string) SCR::Read(.sysconfig.scpm.VERBOSE) == "yes"),
	"switch_mode":	(string) SCR::Read(.sysconfig.scpm.SWITCH_MODE),
	"boot_mode":	(string) SCR::Read(.sysconfig.scpm.BOOT_MODE)
    ];
    y2debug ("scpm configuration: %1", scpm_conf);
    return true;
}

/**
 * writes configuration data to scpm config file (/etc/scpm.conf)
 * @return true
 */
global define boolean WriteConfigFile () ``{

    foreach (string key, any value, (map<string,any>) scpm_conf, ``{
	path agent = add(.sysconfig.scpm, toupper(key));
	if (is (value, boolean))
	    SCR::Write(agent, ((boolean) value) ? "yes" : "no");
	else
	    SCR::Write(agent, (string) value);
    });
    return true;
}


/**
 * Initialize the SCPM agent.
 * @return true on success
 */
define boolean Initialize() ``{

    // popup label, %1 is required application
    if (!Package::InstallAllMsg (["scpm"], _("<p>To use the profile manager, the package <b>%1</b> is required.<br>
Install it now?</p>
")))
         return false;

    string tmpdir	= (string) SCR::Read(.target.tmpdir);
    progresspath	= tmpdir + progressfile;
    hashpath		= tmpdir + hashfile;
    boolean ret		= (boolean) SCR::Execute(.scpm, tmpdir);

    if (ret == nil) ret = false;
    if (ret == false)
        SetError();

    return ret;
}

/**
 * Checks if SCPM is enabled/disabled/initialized.
 * @return true on success
 */
define boolean ReadSCPMStatus() ``{

    // get the scpm_status_t struct as a map
    map status = (map) SCR::Read (.scpm.status);
    if (status == nil)
    {
        SetError();
        return false;
    }

    enabled		= status["enabled"]:false;
    initialized		= status["initialized"]:false;
    needs_reinit	= initialized && status["needs_reinit"]:false;
    needs_recover	= status["needs_recover"]:false;
    return true;
}

/**
 * Calls SCPM::Recover (false) function, which replays journal after the crash
 * (started in separate agen'ts thread, return value must be checked with Wait)
 */
global define void Recover () {

    SCR::Execute (.scpm.recover, $[]);
}

/**
 * Calls SCPM::Recover (true)
 */
global define void Rollback () {

    SCR::Execute (.scpm.rollback, $[]);
}



/**
 * Ask user which action should be taken when scom recovery is necessary
 * @return symbol: `cancel, `recover, `rollback
 */
define symbol AskForRecoveryPopup () {

    symbol ret	= nil;

    string text	=
    // popup text
_("SCPM is currently locked and needs recovery. This may be
the result of an aborted profile switch or similar. You
can have SCPM <b>Recover</b> the last command, which means your
database will be updated and outstanding actions will be
performed. You can also have SCPM <b>Rollback</b> the command, which means
the old system status will be restored if possible.
");

    UI::OpenDialog(`opt(`decorated), `HBox (`HSpacing(1.5),
        `VSpacing (14),
        `VBox (
            `HSpacing (50),
            `VSpacing (1),
            `RichText (text),
            `VSpacing (0.5),
	    `HBox(
		// Push button label
		`PushButton(`id(`recover),`opt(`default),_("&Recover")),
		`HSpacing(1),
                // Push button label
	        `PushButton(`id(`rollback), _("Ro&llback")),
		`HSpacing(1),
		`PushButton (`id(`cancel), Label::CancelButton ())
	    ),
            `VSpacing (0.5)
	),
        `HSpacing(1.5)
    ));

    ret = (symbol) UI::UserInput();
    UI::CloseDialog();
    return ret;
}

/**
 * Checks the return value of agent's thread
 * @return boolean true if thread finished succesfully
 */
global define boolean Wait() ``{
    boolean ret = (boolean) SCR::Read(.scpm.exit_status );
    if (!ret)
        SetError();
    return ret;
}

/**
 * Gets the hash marks (to show in ProgressPopup) from the hashfile
 * @return number of characters in hashfile
 */
global define integer GetHashMarks() ``{

    string all = (string) SCR::Read(.target.string, hashpath);
    if (all == nil || all == "") return 0;
    return (size(all) - (100 * hash_size));
}

/**
 * Reads the file with the progress informations.
 * @param everything if set to true, returns the entire rest of file
 * @return string the text to show in ProgressPopup (one line in normal case)
 */
global define string GetProgressText(boolean everything) ``{

    string ret = "";
    string all = (string) SCR::Read(.target.string, progresspath);

    // check for non-existent file
    if (all == nil) return ret;

    list all_l		= splitstring (all, "\n");
    string current	= all_l[progress_size]:"";
    string last		= all_l[progress_size - 1]:"";

    if (!everything) // return only one line
    {
        // last line has been updated:
        if (last_ret != "" && last_ret != last)
        {
            ret = substring (last, size(last_ret), size(last)-size(last_ret));
            last_ret = all_l[progress_size - 1]:"";
        }
        // continue with the new line
        else if (progress_size < size(all_l) && current !="" && current !="\n")
        {
            ret = current;
            if (last_ret != "") {
                last_ret = ret;
                ret = "\n" + ret;
            }
            else last_ret = ret;
            progress_size = progress_size + 1;
        }
    }
    else // return everything to the end of file
    {
        if (last_ret != "" && last_ret != last)
        {
            ret = substring (last, size(last_ret), size(last)-size(last_ret));
        }
        while (progress_size < size(all_l) &&  current != "" && current != "\n")
        {
            ret = "\n" + current;
            progress_size = progress_size + 1;
            current = all_l[progress_size]:"";
        }
    }
    return ret;
}

/**
 * Popup for showing progress informations
 * @param position of this progress:
 *  (if "first", popup is not closed, for "last" popup is not created)
 * @param start start of progress (mainly 0)
 * @param end end of progress (mainly 100)
 * @return boolean true
 */
global define boolean ProgressPopup (string position, integer start, integer end) {

    if (position != "last")
    {
	UI::OpenDialog(`opt(`decorated), `HBox(`HSpacing(1.5), `VBox(
	    `HSpacing (60),
            `VSpacing(1),
	    // LogView label:
            `LogView(`id(`progress),_("Progress Information"), 10, 0),
            `VSpacing(1),
            `ProgressBar(`id(`pb), "", 100, 0),
            `VSpacing(1),
	        `HBox(
	            `Right(`PushButton(`id(`close), `opt(`default, `key_F10),
                    Label::CloseButton())),
	            `HSpacing(1)
	            ),
            `VSpacing(1)),
	`HSpacing(1.5)));

	UI::ChangeWidget(`id(`close), `Enabled, false);
    }

    string progresstext = "";
    integer hashmarks = start;
    last_ret = "";

    UI::BusyCursor();
    do
    {
        sleep(5);
        hashmarks = GetHashMarks();
        UI::ChangeWidget(`id(`pb), `Value, hashmarks);

        progresstext = GetProgressText(false);
        if (progresstext != "") {
	    string recoded = (string)
		UI::Recode(WFM::GetEnvironmentEncoding(),"UTF-8",progresstext);
            UI::ChangeWidget(`id(`progress), `LastLine, recoded);
        }
    }
    while (hashmarks < end);

    // next hundred of hash marks
    if (hashmarks >= 100)
        hash_size = hash_size + 1;

    // read to the end of file
    progresstext = GetProgressText(true);
    if (progresstext != "") {
	string recoded = (string)
	    UI::Recode (WFM::GetEnvironmentEncoding(),"UTF-8",progresstext);
        UI::ChangeWidget(`id(`progress), `LastLine, recoded);
    }
    if (position == "first") // hack: missing newline
        UI::ChangeWidget(`id(`progress), `LastLine, "\n");

    UI::NormalCursor();
    if (position != "first")
    {
	UI::ChangeWidget(`id(`close), `Enabled, true);
	UI::UserInput();
        UI::CloseDialog();
    }
    return true;
}


/**
 * Read all profile-manager settings
 * @return true on success
 */
global define boolean Read() ``{

    // profile-manager Read dialog caption:
    string caption = _("Initializing Profile Manager Configuration");

    integer steps = 5;

    Progress::New( caption, " ", steps, [
	    // progress stage
	    _("Initialize SCPM"),
	    // progress stage
	    _("Read the SCPM state"),
	    // progress stage
	    _("Read resource groups"),
	    // progress stage
	    _("Read SCPM settings"),
	], [
	    // progress step
	    _("Initializing SCPM..."),
	    // progress step
	    _("Reading the SCPM state..."),
	    // progress step
	    _("Reading resource groups..."),
	    // progress step
	    _("Reading SCPM settings..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    if (! NetworkService::ConfirmNetworkManager())
    {
	return false;
    }

    // initialize
    Progress::NextStage();
    if(!Initialize())
    {
	// Error message: %1 is special error message
	Report::Error(sformat(_("Cannot initialize SCPM:\n%1"), scpm_error));
        return false;
    }

    // read status
    Progress::NextStage();
    if(!ReadSCPMStatus())
    {
	// Error message: %1 is special error message
	Report::Error(sformat(_("Cannot read SCPM status:\n%1"), scpm_error));


        return false;
    }
    if (needs_reinit)
    {
	if (Mode::commandline ())
	{
	    // error popup
	    Report::Error (_("Reinitialization is needed."));
	    return false;
	}
	// yes/no popup
	if (Popup::YesNo (_("SCPM is currently locked because your system
installation has changed.
This is usually caused by a system update. Therefore, the data saved in
your profiles may be inconsistent, making it necessary to reininitialize
SCPM. This also means the saved profiles will be lost and need to be
set up again from scratch.
Perform the reinitialization now?
")))
	{
	    // force enabling
	    SCR::Write(.scpm.status.enabled.force, true);
	}
    }

    if (needs_recover)
    {
	if (Mode::commandline ())
	{
	    // error popup
	    Report::Error (_("Recovery or rollback is needed."));
	    return false;
	}
	symbol recover_ret	= AskForRecoveryPopup ();
	if (recover_ret == `recover)
	    Recover ();
	else if (recover_ret == `rollback)
	    Rollback ();
	else return false;
	ProgressPopup ("", 0, 100);
	if (!Wait())
	{
	    ShowError ();
	    return false;
	}
    }

    Progress::NextStage();
    if (!ReadResourceGroups())
    {
	// error message (%1 is additional error message)
	Report::Error (sformat(_("Cannot read resource groups:\n%1"),
	    scpm_error));
    }

    // read user settings
    Progress::NextStage();

    ReadConfigFile ();

    users_allowed = GetUsersAllowed ();

    ReadUsers ();

    Progress::NextStage();
    // progress stage
    Progress::Title (_("Finished"));

    return true;
}

/**
 * Enables or disables SCPM
 * (depends on value of enabled variable).
 * @return true on success
 */
global define boolean WriteSCPMStatus() ``{

    boolean ret = SCR::Write(.scpm.status.enabled, enabled);
    if (!ret)
        SetError();
    return ret;

}

/**
 * Enables SCPM for the first time
 */
global define void WriteStatusFirst() ``{
    SCR::Execute(.scpm.enable.first);
}

/**
 * general function for writing status (enable/disable)
 */
global define boolean WriteStatus () {

    boolean ret	= true;
    if (status_modified)
    {
	if (!initialized)
	{
	    initialized	= true;
	    WriteStatusFirst ();
	    ProgressPopup("",0,100);
	    if (!Wait())
	    {
		enabled = false;
		ret	= false;
	    }
	}
	else
	{
	    ret	= WriteSCPMStatus ();
	    if (!ret)
		enabled	= !enabled;
	}
    }
    if (!ret)
    {
	// Error message. %1 is error report
	Report::Error(sformat(_("Writing SCPM status was not successful:
%1"), scpm_error));
    }
    else
    {
	status_modified	= false;
	save_db		= true;
    }
    return ret;
}

/**
 * Rebuilds SCPM database after changing resources.
 * @return true on success
 */
global define boolean RebuildDB() ``{

    if (!initialized)
	return true; // no need for rebuild

    boolean ret = (boolean) SCR::Execute(.scpm.resources.rebuild);
    if (!ret)
        ShowError();
    return ret;
}

/**
 * function for writing modifications in resource groups
 */
global define boolean WriteResourceGroups () {

    boolean ret	= true;
    if (resource_groups_modified)
    {
	ret	= SaveResourceGroups ();
	if (ret)
	{
	    RebuildDB();
	    resource_groups_modified	= false;
	    save_db			= true;
	}
	else
	{
	    // Error popup text, %1 is additional error text
	    Report::Error(sformat(_("Saving resource groups failed:
%1"),
		scpm_error));
	}
    }
    return ret;
}

/**
 * Write all profile-manager settings
 * @return true on success
 */
global define boolean Write() ``{

    // profile-manager Write dialog caption:
    string caption = _("Writing Profile Manager Configuration");

    list<string> stagelist = [
	// progress stage:
	_("Write the SCPM database"),
	// progress stage:
	_("Write SCPM status"),
	// progress stage:
	_("Write resource groups"),
	// progress stage:
	_("Write SCPM settings"),
    ];

    list steplist = [
        // progress step:
	_("Writing the SCPM database..."),
	// progress step:
	_("Writing SCPM status..."),
	// progress step:
	_("Writing resource groups..."),
	// progress step:
	_("Writing SCPM settings..."),
	// progress step:
	_("Finished")
    ];

    sleep (100);

    integer steps = size (steplist);

    Progress::New (caption, " ", steps, stagelist, steplist, "");

    Progress::NextStage();
    WriteStatus ();

    Progress::NextStage();
    WriteResourceGroups ();

    Progress::NextStage();
    if (save_db)
    {
	if (!SCR::Write(.scpm, nil))
	{
	    SetError();
	    // Error message, %1 is extra error text
	    Report::Error(sformat(_("Cannot write SCPM database:\n%1"),scpm_error));
	}
	else
	    save_db	= false;
    }

    Progress::NextStage();
    if (conf_modified && !WriteConfigFile())
    {
	// Error message:
	Report::Error (_("Cannot write SCPM settings."));
    }

    if (users_modified)
    {
	WriteUsers ();
	WriteUsersAllowed ();
    }

    Progress::NextStage();

    // progress stage
    Progress::Title (_("Finished"));

    return true;
}

/**
 * Checks if the name of the new profile consists of
 * valid characters: [a-zA-Z0-9_-.]
 * @param name Name of the new profile.
 * @return true if valid
 */
global define boolean CheckNameValidity(string name) ``{

    if (size(name) < 1)
        return false;
    string additional	= "-_.@#"; // additional characters allowed
    if (name != filterchars (name, String::CAlnum () + additional))
    {
	y2milestone ("invalid characters in profile name");
        return false;
    }
    if (issubstring (additional, substring (name, 0, 1)))
    {
	y2milestone ("profile name must start with letter or digit");
        return false;
    }
    return true;
}

/* EOF */
}
