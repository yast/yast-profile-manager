/**
 * File:	modules/ProfileManager.ycp
 * Package:	Configuration of profile-manager
 * Summary:	Data for configuration of profile-manager, input and output funcs.
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of profile-manager.
 * Input and output routines.
 */

{

module "ProfileManager";
textdomain "profile-manager";

import "Progress";
import "Report";

include "profile-manager/routines.ycp";
//include "require.ycp";

/**
 * Is the module runing for the first time?
 */
global boolean first_time = false;

/**
 * Is SCPM enabled?
 */
global boolean enabled = false;

/**
 * Is SCPM initialized?
 * This is set to true after first enabling.
 */
global boolean initialized = false;

/**
 * Is set "close popups automaticaly" check?
 */
global boolean close_popups = false;

/**
 * This shows if the "autoswitch" was set while adding a new profile.
 */
global boolean auto = false;

/**
 * Map of actual profiles and its descriptions.
 * It is read in ReadProfiles() and ReadProfilesDescription().
 * @example
 *  $[ "default" : "This is the default",
 *     "home" : "My home profile",
 *   ...
 *  ]
 */
global map profiles = $[];

/**
 * Map of selected profile's settings.
 * It is read in GetProfile() and written in SetProfile().
 * @example
 *  $[ "name" : "home",
 *     "description" : "My home profile",
 *     "prestart" : "",
 *     "postart" : "/tmp/poststart_script",
 *     "prestop" : "",
 *     "poststop" : ""
 *  ]
 */
global map profile_settings = $[];

/**
 * The name of current resource set.
 * It is read in ReadCurrentResource().
 */
global string current_resources = "";

/**
 * This is the name of the active profile.
 * It is read in ReadActiveProfile().
 */
global string active_profile = "";

/**
 * This is the name of the profile selected in some widget.
 */
global string selected_profile = "";

/**
 * The list of predefined resource sets.
 * @example
 *  [ "typical",
 *    "network_only"
 *  ]
 */
global list resource_sets_predefined = [];

/**
 * The list of user defined resource sets.
 */
global list resource_sets_individual = [];

/**
 * This map represents the switch_info struct.
 * It is read in PrepareSwitch() and used by Switch().
 * @example
 *  $[ "profile_name": "home",
 *     "profile_modified": true,
 *     "modified_resources":
 *      [ $[ "resource_name": "/etc/X11/XF86Config",
 *           "resource_type": "file",
 *           "is_new": false,
 *           "is_deleted": true,
 *           "save": true
 *        ]
 *      ]
 *  ]
 */
global map switch_info = $[];

/**
 * This variable defines the action whis will be done
 * with the profile in the ProfileSettingsDialog.
 * Can be "new", "copy" or "edit".
 */
global string profile_action = "";

global integer active_resource = 0;
global string active_resource_name = "";
global string last_ret = "";

/**
 * In this map are written the variables close_popups and first_time.
 * It is read from the file in ReadUserSettings()
 * and written to the file in WriteUserSettings().
 */
map state = $[];

integer progress_size = 0;

/**
 * The name of the file, where the progress state is beeing written.
 * (The same name must use the scpm agent!)
 */
string progressfile = "/scpm.progress";
string hashfile = "/scpm.hash";

/**
 * The name of the file, where are written the resource changes.
 * This file is checked after pushing "Show changes" button.
 * (The same name must use the scpm agent!)
 */
string changesfile = "/scpm.changes";
string tmpfile = "/scpm.tmp";
string progresspath = "";
string hashpath = "";
string changespath = "";
string tmppath = "";
string tmpdir = "";

global boolean text_mode = true;

global boolean proposal_valid = false;
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;


/**
 * Read all profile-manager settings
 * @return true on success
 */
global define boolean Read() ``{

    // profile-manager Read dialog caption:
    string caption = _("Initializing profile manager configuration");

    integer steps = 8;

    integer sl = 10;
    sleep(sl);


    Progress::New( caption, " ", steps, [
		// progress stage
	    _("Initialize SCPM"),
		// progress stage
	    _("Read the SCPM state"),
		// progress stage
	    _("Read the list of profiles"),
		// progress stage
	    _("Read active profile"),
		// progress stage
	    _("Read the profiles descriptions"),
		// progress stage
	    _("Read current resource set"),
		// progress stage
	    _("Read user settings"),
	], [
		// progress stage
	    _("Initializing SCPM..."),
		// progress stage
	    _("Reading the SCPM state..."),
		// progress stage
	    _("Reading the profiles..."),
		// progress stage
	    _("Reading active profile..."),
		// progress stage
	    _("Reading the profiles descriptions..."),
		// progress stage
	    _("Reading current resource set..."),
		// progress stage
	    _("Reading user settings..."),
		// progress stage
	    _("Finished")
	],
	""
    );


    // get display mode
    map display_info = UI::GetDisplayInfo();
    text_mode = display_info["TextMode"]:true;

    // initialize
    if(Abort()) return false;
    Progress::NextStage();
    if(!Initialize())
    {
		// Error message:
		Report::Error(_("Cannot initialize SCPM!"));
        return false;
    }
    sleep(sl);

    // read
    if(Abort()) return false;
    Progress::NextStage();
    if(!ReadSCPMStatus())
    {
		// Error message:
		Report::Error(_("Cannot read SCPM status!"));
        return false;
    }
    sleep(sl);

    // read
    if(Abort()) return false;
    Progress::NextStage();
	if (enabled)
	    if(!ReadProfiles())
			// Error message:
			Report::Error(_("Cannot read profiles!"));
    sleep(sl);

    // read
    if(Abort()) return false;
    Progress::NextStage();
	if (enabled)
	    if(!ReadActiveProfile())
			// Error message:
			Report::Error(_("Cannot read active profile!"));
    sleep(sl);

    // read
    if(Abort()) return false;
    Progress::NextStep();
	if (enabled)
	    if(!ReadProfilesDescriptions())
			// Error message:
			Report::Error(_("Cannot read profiles descriptions!"));
    sleep(sl);

    // read current resources
    if(Abort()) return false;
    Progress::NextStage();
	if(!ReadCurrentResources())
		// Error message:
		Report::Error(_("Cannot read current resources!"));
    sleep(sl);

    // read user settings
    if(Abort()) return false;
    Progress::NextStage();
	if(!ReadUserSettings())
		// Error message:
		Report::Error(_("Cannot read user settings!"));
    sleep(sl);

    if(Abort()) return false;
	// progress stage
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Write all profile-manager settings
 * @return true on success
 */
global define boolean Write() ``{

    // profile-manager Write dialog caption:
    string caption = _("Writing profile manager configuration");

    integer steps = 2;

    integer sl = 10;


    Progress::New(caption, " ", steps, [
        // progress stage:
	    _("Write the SCPM database"), // we should also save "close popups" check
        // progress stage:
        _("Write user settings"),
	], [
        // progress stage:
	    _("Writing SCPM database..."),
        // progress stage:
	    _("Writing the user settings..."),
        // progress stage:
	    _("Finished")
	],
	""
    );

//    if(Abort()) return false; ... abort is disabled here
    Progress::NextStage();
    if(!SCR::Write(.scpm, nil))
	    // Error message:
        Report::Error (_("Cannot write SCPM database!"));
    sleep(sl);

    Progress::NextStage();
    if(!WriteUserSettings())
	    // Error message:
        Report::Error (_("Cannot write user settings!"));
    sleep(sl);

    // progress stage:
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Reads the list of aviable profiles.
 * @return true on success
 */
global define boolean ReadProfiles() ``{

    list profiles_l = SCR::Read(.scpm.profiles);

    foreach (`profile, profiles_l, ``{
        profiles = add (profiles, profile, "");
    });

    if (profiles_l == [])
        return false;
    return true;

}

/**
 * Reads the active profile.
 * @return true on success
 */
global define boolean ReadActiveProfile() ``{

    active_profile = SCR::Read(.scpm.profiles.current);

    if (active_profile == nil)
        return false;
    return true;
}

/**
 * Reads the descriptions of all aviable profiles.
 * @return true on success
 */
global define boolean ReadProfilesDescriptions() ``{

    // read the descriptions of each profile
    map profilesm = profiles;

    foreach (`profile, `d, profilesm, ``{
        string desc = SCR::Read(.scpm.profiles.description, profile);
        profiles = add (profiles, profile, desc);
    });
    return true;
}

/**
 * Check if the module is run for first time and
 * reads user settings (currently close_popups check)
 * @return true on success
 */
define boolean ReadUserSettings() ``{

    SCR::Execute (.target.bash, "/bin/touch /var/lib/YaST2/scpm.ycp");
    state = SCR::Read (.target.ycp, "/var/lib/YaST2/scpm.ycp");

    if (state == nil || state == $[])
		first_time = true;
	else
		close_popups = lookup(state, "close_popups", false);
    return true;
}

/**
 * Writes the user settings (currently close_popups check).
 * @return true on success
 */
global define boolean WriteUserSettings() ``{

    state = $[];
    state = add (state, "first_time", false);
    state = add (state, "close_popups", close_popups);
    boolean ret = SCR::Write(.target.ycp, "/var/lib/YaST2/scpm.ycp", state);

	return ret;
}


/**
 * Initialize the SCPM agent.
 * @return true on success
 */
define boolean Initialize() ``{

    tmpdir = SCR::Read(.target.tmpdir);
    progresspath = tmpdir + progressfile;
    hashpath = tmpdir + hashfile;
    changespath = tmpdir + changesfile;
    tmppath = tmpdir + tmpfile;
    y2debug("progresspath=%1, hashpath=%2", progresspath, hashpath);

    boolean ret = SCR::Execute(.scpm, tmpdir);

    return ret;
}

/**
 * Checks if SCPM is enabled/disabled/initialized.
 * @return true on success
 */
define boolean ReadSCPMStatus() ``{

    list stat = SCR::Read(.scpm.status);
    if (stat == nil)
        return false;

    enabled = select (stat, 0, false);
    initialized = select (stat, 1, false);
    return true;
}


/**
 * Reads the current resource set.
 * @return true on success
 */
global define boolean ReadCurrentResources() ``{

    string cur = SCR::Read(.scpm.resources.current);

    if (cur == nil || cur =="")
        return false;

    current_resources = cur;
    return true;
}

/**
 * Reads the list of aviable resource sets.
 * @return true on success
 */
global define boolean ReadResourceSets() ``{

    list sets = [];
    sets = SCR::Read(.scpm.resources);

    if (sets == nil)
        return false;

    resource_sets_predefined = select (sets, 0, []);
    resource_sets_individual = select (sets, 1, []);
    return true;
}


/**
 * Reads the settings of the selected profile
 * (we already have description from ReadProfileDescriptions()).
 * @return true on success
 */
global define boolean GetProfile() ``{

    // the settings of not yet created profile
    if (profile_action == "new") {
        profile_settings = $[];
        return true;
    }

    profile_settings = add (profile_settings, "name", selected_profile);
    profile_settings = add (profile_settings, "description", lookup(profiles, selected_profile,""));

    profile_settings = add (profile_settings, "prestart",
        SCR::Read(.scpm.profiles.prestart, selected_profile));
    profile_settings = add (profile_settings, "poststart",
        SCR::Read(.scpm.profiles.poststart, selected_profile));
    profile_settings = add (profile_settings, "prestop",
        SCR::Read(.scpm.profiles.prestop, selected_profile));
    profile_settings = add (profile_settings, "poststop",
        SCR::Read(.scpm.profiles.poststop, selected_profile));

    return true;
}

/**
 * Creates a new profile.
 * @param name Name of the new profile
 * @return true
 */
global define boolean AddProfile(string name) ``{

    SCR::Execute(.scpm.profiles.add, name, auto);
    return true;
}

/**
 * Creates a new profile by copying old one.
 * @param source Name of the source profile
 * @param new Name of the new profile
 * @return true
 */
global define boolean CopyProfile(string source, string new) ``{

    SCR::Execute(.scpm.profiles.copy, source, new);
    return true;
}

/**
 * Renames a profile.
 * @param old Name of the affected profile
 * @param new New name of the profile
 * @return true on success
 */
global define boolean RenameProfile(string old, string new) ``{


    boolean ret = SCR::Execute(.scpm.profiles.rename, old, new);
    if (ret)
    {
        string desc = lookup(profiles, old, "");
        profiles = filter (`name, `desc, profiles, ``(name != old));
        profiles = add (profiles, new, desc);
        if (active_profile == old)
            active_profile = new;
    }
    return ret;
}


/**
 * Sets the parameters of the profile.
 * Uses the global variable profile_settings.
 * @param name Name of the affected profile
 * @return true on success
 */
global define boolean SetProfile(string name) ``{

    string desc = deletechars(lookup(profile_settings, "description",""), "\n");

    boolean ret = SCR::Write(.scpm.profiles.description, desc, name);
    ret = ret &&  SCR::Write(.scpm.profiles.prestart,
        lookup(profile_settings, "prestart",""), name);
    ret = ret &&  SCR::Write(.scpm.profiles.poststart,
        lookup(profile_settings, "poststart",""), name);
    ret = ret &&  SCR::Write(.scpm.profiles.prestop,
        lookup(profile_settings, "prestop",""), name);
    ret = ret &&  SCR::Write(.scpm.profiles.poststop,
        lookup(profile_settings, "poststop",""), name);

    if (ret)
        profiles = add (profiles, name, desc);

    return ret;
}


/**
 * Sets the file permitions of scripts from profile_settings to 700.
 * @return true on success
 */
global define boolean SetFilePermitions() ``{

	string file = "";
	file = lookup(profile_settings, "prestart","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/bin/chmod 700 %1",file))) != 0)
	return false;

	file = lookup(profile_settings, "poststart","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/bin/chmod 700 %1",file))) != 0)
	return false;

	file = lookup(profile_settings, "prestop","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/bin/chmod 700 %1",file))) != 0)
	return false;

	file = lookup(profile_settings, "poststop","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/bin/chmod 700 %1",file))) != 0)
	return false;

    return true;
}


/**
 * Deletes the profile.
 * @param to_delete Name of the affected profile
 * @return true on success
 */
global define boolean DeleteProfile(string to_delete) ``{

    boolean ret = SCR::Execute(.scpm.profiles.delete, to_delete);
    if (ret)
        profiles = filter (`name, `desc, profiles, ``(name != to_delete));
    return ret;
}

/**
 * Calls SCPM::PrepareSwitch(), which drops switch_info map to file
 * @return true
 */
global define boolean PrepareSwitch() ``{

    SCR::Execute(.scpm.switch.prepare, selected_profile);

    return true;

}

/**
 * Sets all "save" flags in switch_info map to true.
 * @return true on success
 */
global define boolean SaveSwitchInfo() ``{

    list resources = lookup(switch_info, "modified_resources",[]);

    integer i = 0;
    while (i<size (resources)) {
        switch_info["modified_resources",i,"save"] = true;
        i = i + 1;
    }

    y2debug("switch_info:%1", switch_info);
    return true;
}

/**
 * Sets all "save" flags in switch_info map to false.
 * @return true on success
 */
global define boolean DropSwitchInfo() ``{

    list resources = lookup(switch_info, "modified_resources",[]);

    integer i = 0;
    while (i<size (resources)) {
        switch_info["modified_resources",i,"save"] = false;
        i = i + 1;
    }

    y2debug("switch_info:%1", switch_info);

    return true;
}

/**
 * Switchs to the selected profile.
 * @return true on success
 */
global define boolean Switch() ``{

    y2milestone ("Switching from profile \"%1\" to profile \"%2\"...",active_profile,selected_profile);
    SCR::Execute(.scpm.switch, switch_info);
    return true;

}

/**
 * Enables or disables SCPM
 * (depends on value of enabled variable).
 * @return true on success
 */
global define boolean WriteSCPMStatus() ``{

    boolean ret = SCR::Write(.scpm.status.enabled, enabled);
    return ret;

}

/**
 * Enables SCPM for the first time
 * @return true
 */
global define boolean WriteStatusFirst() ``{
    SCR::Execute(.scpm.enable.first);
    return true;
}

/**
 * Changes the current resources.
 * @param resource_set Name of new resource set
 * @return true on success
 */
global define boolean WriteResources(string resource_set) ``{

    boolean ret = SCR::Write(.scpm.resources.current, resource_set);
    return ret;

}

/**
 * Rebuilds SCPM database after changing resources.
 * @return true on success
 */
global define boolean RebuildDB() ``{

    boolean ret = SCR::Execute(.scpm.resources.rebuild);
    return ret;

}

/**
 * Not implemented yet
 * @param set
 * @return true on success
 */
global define boolean DeleteResourceSet(string set) ``{

    boolean ret = SCR::Execute(.scpm.resources.delete, set);
    if (ret)
        resource_sets_individual = filter (`name, resource_sets_individual,
            ``(name != set));
    return ret;
}

/**
 * Not implemented yet
 * @param set
 * @param newset
 * @return true on success
 */
global define boolean CopyResourceSet(string set, string newset) ``{

    boolean ret = SCR::Execute(.scpm.resources.copy, set, newset);

    if (ret)
        resource_sets_individual = add (resource_sets_individual, newset);

    return ret;
}

/**
 * Runs application with an info page
 * @return
 */
global define string RunIntroApplication() ``{

    y2debug("textmode = %1", text_mode);
    string ret = "";

    if (text_mode)
    {
        if (SCR::Execute (.target.bash, "/usr/bin/test -x /usr/bin/info") == 0)
        {
            string output = tmpdir + "/info.out";
            SCR::Execute(.target.bash_output,"info scpm >" + output + " 2>/dev/null");
            ret = SCR::Read(.target.string, output);
        }
        else
            SCR::Execute(.target.bash,"man scpm > output 2>/dev/null");
    }
    else
    {
/*
    if (IsPackageInstalled("kdebase3") || IsPackageInstalled("kdebase3-konqueror"))
*/
	    if (SCR::Execute (.target.bash, "/usr/bin/test -x /opt/kde3/bin/konqueror") == 0)
            SCR::Execute(.target.bash_background,"konqueror info:/scpm/introduction");
        else if (SCR::Execute (.target.bash, "/usr/bin/test -x /usr/bin/info") == 0)
            SCR::Execute(.target.bash_background,"xterm -e info scpm");
        else
            SCR::Execute(.target.bash_background,"xterm -e man scpm");
    }
    return ret;
}

/**
 * Checks, what changes will be done to the selected resource after switch.
 * Uses global variable active_resource.
 * @return string The changes.
 */
global define string ShowChanges() ``{

    list resources = lookup (switch_info, "modified_resources", []);

    map resource = select (resources, active_resource, $[]);

    active_resource_name = lookup(resource, "resource_name","");
    string type = lookup(resource, "resource_type","");

    SCR::Execute(.scpm.profiles.changes, type, active_resource_name);
    string changes = SCR::Read(.target.string, changespath); //check for error?

    if (changes == "" || changes == nil)
        changes = "";
    else
    {
        list lines = splitstring (changes, "\n");
        changes = mergestring (lines, "<br>");
    }
    return changes;
}

/**
 * Sets the "save" flag of selected resource to the opposite value.
 * @return true on success
 */
global define boolean SetSaveFlag() ``{

    boolean s = switch_info["modified_resources",active_resource,"save"]:false;
    switch_info["modified_resources",active_resource,"save"] = !s;

    return true;
}

/**
 * Creates the item list for the Table widget.
 * @return list of items
 */
global define list GetProfilesAsItems() ``{

    list items = [];
    items = maplist (`name, `descr, profiles, ``{
        if (name == active_profile)
            return `item(`id(name),"---->",name,descr);
        else
            return `item(`id(name),"",name,descr);
    });
    return items;
}

/**
 * Creates the item list for the Table widget.
 * @return list of items
 */
global define list GetResourcesAsItems() ``{

    list resources = lookup (switch_info, "modified_resources", []);
    list items = [];
    integer i = 0;

    foreach (`resource, resources, ``{
        string flag = "";
        if (lookup(resource,"is_new",false))
            flag = "NEW";
        else if(lookup(resource,"is_deleted",false))
            flag = "DELETED";


        items = add(items, `item(`id(i),
                                 lookup(resource,"save",false)? "X":"",
                                 flag,
                                 lookup(resource,"resource_name",""),
                                 lookup(resource,"resource_type","")));
        i = i + 1;
    });
    return items;
}

/**
 * Checks if the name of the new profile consists of
 * valid characters: [a-zA-Z0-9_-.]
 * @param name Name of the new profile.
 * @return true if valid
 */
global define boolean CheckNameValidity(string name) ``{

    if (size(name) < 1)
        return false;
    if (name != filterchars(name,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_."))
        return false;
    string first = substring(name,0,1);
    if (size(deletechars(first,"-_.")) <1)
        return false;
    return true;
}

/**
 * Checks the existence of the scripts from
 * @param new_settings The map with paths to scripts
 * @return true if ok
 */
global define boolean CheckFilesValidity(map new_settings) ``{

	string file ="";

	// test -x ???
	file = lookup(new_settings, "prestart","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/usr/bin/test -e %1",file))) != 0)
	return false;

	file = lookup(new_settings, "poststart","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/usr/bin/test -e %1",file))) != 0)
	return false;

	file = lookup(new_settings, "prestop","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/usr/bin/test -e %1",file))) != 0)
	return false;

	file = lookup(new_settings, "poststop","");
	if (file != "" &&
		(SCR::Execute (.target.bash, sformat("/usr/bin/test -e %1",file))) != 0)
	return false;

    return true;
}

/**
 * Checks if the profile settings was modified.
 * @param new_settings The map of new profile settings.
 * @return true if modified
 */
global define boolean ModifiedSettings(map new_settings) ``{

    boolean ret = false;

    foreach (`type, `value, profile_settings, ``{
        if (type != "name")
            if (value != lookup(new_settings, type, "")) ret = true;
    });

    return ret;
}

/**
 * @return
 */
global define integer GetHashMarks() ``{

    string all = SCR::Read(.target.string, hashpath);
    return (size(all));
}

/**
 * Reads the file with the progress informations.
 * @return string One line of the text to show in ProgressPopup()
 */
global define string GetProgressText(boolean everything) ``{

    string ret = "";
    string all = SCR::Read(.target.string, progresspath);
    list all_l = splitstring (all, "\n");

    string current = select(all_l,progress_size,"");
    string last = select(all_l,progress_size - 1,"");

    if (!everything) { //we return only one line

    // last line has been updated:
    if (last_ret != "" && last_ret != last)
    {
        ret = substring (last, size(last_ret), size(last)-size(last_ret));
        last_ret = select(all_l, progress_size - 1, "");
    }
    // continue with the new line
    else if (progress_size < size(all_l) &&  current != "" && current != "\n")
    {
        ret = current;
        if (last_ret != "") {
            last_ret = ret;
            ret = "\n" + ret;
        }
        else last_ret = ret;
        progress_size = progress_size + 1;
    }
    }
    else { // return everything to the end of file

    if (last_ret != "" && last_ret != last)
    {
        ret = substring (last, size(last_ret), size(last)-size(last_ret));
    }
    while (progress_size < size(all_l) &&  current != "" && current != "\n")
    {
        ret = "\n" + current;
        progress_size = progress_size + 1;
        current = select(all_l,progress_size,"");
    }
    }
    return ret;
}

/**
 * Reads the switch info map,
 * which was dumped to file by agent's thread
 * @return boolean true on success
 */
global define boolean ReadSwitchInfo() ``{

    switch_info = SCR::Read(.target.ycp, tmppath);
    if (switch_info == nil)
    {
        switch_info = $[];
        return false;
    }
    y2milestone("switch_info: %1",switch_info);
    return true;
}

/**
 * Checks the return value of agent's thread
 * @return boolean true if thread finished succesfully
 */
global define boolean Wait() ``{
    return SCR::Read(.scpm.exit_status );
}

/* EOF */
}
